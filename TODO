- Move configuration delivery to shm/LRU, away from local access handler instantiation

- Rule syntax rewrite
	- Move definitions to shm/LRU cache, away from separate modules?
	- One var per rule
	- One primitive value per var key; logical OR implemented with multiple rules
	- Enable chaining in process loop
	- Remove extraneous string primitives
		Define as flat/text JSON, compile down
	- Inherit action from ruleset
	- Auto rule nolog if action == chain

- Memoize parse_collection results

- Implement request signature memoization
	- Use murmur2 hash (FFI)
	- Investigate proper hash keys

- Add more operator[]() items
	- Allow for transient data storage
		- How does this model match our philosophy of efficient, minimalistic processing?
	- Skip
	- Chain

- Function cleanup
	- Extraneous memcpy, allocations
	- Localize utility functions
	- table_has_value
		- O(n) time reduced to O(log(n)) time with table_has_key
		- opts.mode, client whitelist, method blacklist, rule ignore

- Collections table cleanup
	- Separate tables for arg keys/values
		- How do we associated matched values with respective keys?

- Jump rule processor if no valuable match is found for expensive rule sets
	- XSS/SQLi
	- Mimic CRS !@pm

- Additional rule/behavior matching ideas
	- Validate bot UA/IP
	- Session cookie stealing

- Implement behavior analysis
	- Request rate
	- Request signature distribution
	- Upstream response status
	- Request/match ratio

- Compile down using LuaJIT
	- Prod/debug builds

- Add X-WAF-EVENTS headers to upstream req

- Unit testing with Test::Socket::Nginx
